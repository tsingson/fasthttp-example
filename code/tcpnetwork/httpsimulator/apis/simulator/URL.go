// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package simulator

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type URLT struct {
	Protocol   string
	IPAddress  string
	Port       int32
	Path       string
	Parameters string
	Anchor     string
}

func (t *URLT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	ProtocolOffset := builder.CreateString(t.Protocol)
	IPAddressOffset := builder.CreateString(t.IPAddress)
	PathOffset := builder.CreateString(t.Path)
	ParametersOffset := builder.CreateString(t.Parameters)
	AnchorOffset := builder.CreateString(t.Anchor)
	URLStart(builder)
	URLAddProtocol(builder, ProtocolOffset)
	URLAddIPAddress(builder, IPAddressOffset)
	URLAddPort(builder, t.Port)
	URLAddPath(builder, PathOffset)
	URLAddParameters(builder, ParametersOffset)
	URLAddAnchor(builder, AnchorOffset)
	return URLEnd(builder)
}

func (rcv *URL) UnPackTo(t *URLT) {
	t.Protocol = string(rcv.Protocol())
	t.IPAddress = string(rcv.IPAddress())
	t.Port = rcv.Port()
	t.Path = string(rcv.Path())
	t.Parameters = string(rcv.Parameters())
	t.Anchor = string(rcv.Anchor())
}

func (rcv *URL) UnPack() *URLT {
	if rcv == nil {
		return nil
	}
	t := &URLT{}
	rcv.UnPackTo(t)
	return t
}

func (rcv *URLT) Builder() *flatbuffers.Builder {
	b := flatbuffers.NewBuilder(0)
	b.Finish(rcv.Pack(b))
	return b
}

func (rcv *URLT) Marshal() []byte {
	b := flatbuffers.NewBuilder(0)
	b.Finish(rcv.Pack(b))
	return b.FinishedBytes()
}

func UnmarshalURLT(b []byte) *URLT {
	return GetRootAsURL(b, 0).UnPack()
}

type URL struct {
	_tab flatbuffers.Table
}

func GetRootAsURL(buf []byte, offset flatbuffers.UOffsetT) *URL {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &URL{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *URL) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *URL) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *URL) Protocol() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *URL) IPAddress() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *URL) Port() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *URL) MutatePort(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *URL) Path() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *URL) Parameters() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *URL) Anchor() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func URLStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}

func URLAddProtocol(builder *flatbuffers.Builder, Protocol flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(Protocol), 0)
}

func URLAddIPAddress(builder *flatbuffers.Builder, IPAddress flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(IPAddress), 0)
}

func URLAddPort(builder *flatbuffers.Builder, Port int32) {
	builder.PrependInt32Slot(2, Port, 0)
}

func URLAddPath(builder *flatbuffers.Builder, Path flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(Path), 0)
}

func URLAddParameters(builder *flatbuffers.Builder, Parameters flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(Parameters), 0)
}

func URLAddAnchor(builder *flatbuffers.Builder, Anchor flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(Anchor), 0)
}

func URLEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
